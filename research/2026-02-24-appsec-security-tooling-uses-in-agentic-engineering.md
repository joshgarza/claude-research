---
date: 2026-02-24
topic: Appsec security tooling uses in agentic engineering
status: complete
tags: [security, appsec, SAST, DAST, agentic, AI-generated-code, DevSecOps, MCP, supply-chain]
related: [2026-02-14-security-practices.md, 2026-02-14-devops-infrastructure-update.md, 2026-02-23-ai-agent-ticket-orchestration.md]
---

# Appsec Security Tooling Uses in Agentic Engineering

## Context

Static and dynamic security analysis tooling exists to surface potential vulnerabilities in codebases and running applications. With AI coding agents (Claude Code, Cursor, Copilot, Codex) now generating significant portions of production code, the security landscape has shifted: code is produced at velocities that make traditional manual review mathematically impossible to sustain. Research shows approximately 24.7–40% of AI-generated code contains security vulnerabilities — hardcoded secrets, permissive CORS, missing input validation, SQL injection, and XSS being the most common ([Beyond Identity](https://www.beyondidentity.ai/blog/is-ai-generated-code-safe-a-deep-dive-into-claude-code-security), [GroweXX](https://www.growexx.com/blog/ai-generated-code-security-audit/)).

This research investigates: (1) what specific security risks arise from agentic code generation, (2) what OWASP has codified for agentic applications, (3) what free/open-source tooling exists to integrate security scanning into agentic workflows, and (4) practical integration patterns for making agentically-created code more secure.

Prior research in this project covers traditional security practices (2026-02-14-security-practices.md) and DevSecOps supply chain security (devops-infrastructure.md). This file focuses specifically on the agentic engineering intersection.

## Findings

### 1. The Problem: AI Agents Produce Insecure Code at Scale

AI coding agents reliably reproduce specific vulnerability classes:

- **Hardcoded secrets:** Claude Code and Copilot readily produce code with Stripe keys, DB connection strings, and JWT signing secrets inline. Occurs in roughly 70% of reviewed codebases ([Beyond Identity](https://www.beyondidentity.ai/blog/is-ai-generated-code-safe-a-deep-dive-into-claude-code-security)).
- **Permissive CORS:** `Access-Control-Allow-Origin: *` with credentials — generated by default in ~70% of cases.
- **Missing file validation:** AI-generated upload code frequently lacks file type checking, size limits, content-type verification, and filename sanitization.
- **SQL injection:** When not using an ORM, agents often concatenate user input into queries.
- **Weak cryptography:** Training data includes deprecated patterns (MD5, single-round SHA-256) that agents reproduce.
- **Package hallucination:** 19.7% of AI-suggested packages don't exist in actual repositories, creating "slopsquatting" attack surface where attackers register packages matching hallucinated names ([OpenSSF](https://best.openssf.org/Security-Focused-Guide-for-AI-Code-Assistant-Instructions)).

Beyond code-level vulnerabilities, agentic workflows introduce novel attack surfaces:

- **Rules File Backdoor:** Pillar Security demonstrated that Cursor `.cursorrules` and Copilot instruction files can contain Unicode-obfuscated malicious instructions that redirect agent code generation — agents silently insert malicious script tags or backdoors without mentioning them in response logs. GitHub responded with hidden Unicode text warnings (May 2025); Cursor classified it as user responsibility ([Pillar Security](https://www.pillar.security/blog/new-vulnerability-in-github-copilot-and-cursor-how-hackers-can-weaponize-code-agents)).
- **MCP tool poisoning:** Malicious MCP servers inject prompt injection into tool descriptions during handshake, tool shadowing via name collisions, and "rug-pulling" where approved servers get replaced with malicious versions. The MCP spec currently has no requirements for isolation or tool change broadcasting ([Semgrep MCP Security Guide](https://semgrep.dev/blog/2025/a-security-engineers-guide-to-mcp/)).
- **Prompt injection via data:** 30+ CVEs have been disclosed affecting Claude Code, Cursor, and Copilot via prompt injection and MCP tool poisoning ([Secure Code Warrior](https://www.securecodewarrior.com/article/prompt-injection-and-the-security-risks-of-agentic-coding-tools)).

### 2. OWASP Top 10 for Agentic Applications (2026)

Released December 2025 by 100+ industry experts, this is the authoritative framework for agentic AI security risks ([OWASP GenAI](https://genai.owasp.org/resource/owasp-top-10-for-agentic-applications-for-2026/)):

| # | Risk | Key Mitigation |
|---|------|----------------|
| ASI01 | **Agent Goal Hijacking** | Treat all NL input as untrusted; strict content filtering; limit tool privileges |
| ASI02 | **Tool Misuse & Exploitation** | Strict permission scoping; validate all tool arguments; rate limit tool calls |
| ASI03 | **Identity & Privilege Abuse** | Short-lived task-scoped credentials; never cache tokens; least privilege at identity layer |
| ASI04 | **Agentic Supply Chain** | Signed manifests; curated registries; pin versions with integrity hashes; audit MCP configs |
| ASI05 | **Unexpected Code Execution** | Treat generated code as untrusted; hardened sandboxes; remove eval/exec capabilities |
| ASI06 | **Memory & Context Poisoning** | Segment memory by tenant; track provenance; periodic integrity checks |
| ASI07 | **Insecure Inter-Agent Comms** | Mutual TLS; signed payloads; integrity verification; replay protection |
| ASI08 | **Cascading Failures** | Isolation boundaries; circuit breakers; timeouts; rollback mechanisms |
| ASI09 | **Human-Agent Trust Exploitation** | Explicit human confirmation for sensitive actions; display confidence levels |
| ASI10 | **Rogue Agents** | Behavioral monitoring; kill switches; automatic containment; audit logs |

Source: [Startup Defense analysis](https://www.startupdefense.io/blog/owasp-top-10-agentic-ai-security-risks-2026), [Palo Alto Networks](https://www.paloaltonetworks.com/blog/cloud-security/owasp-agentic-ai-security/)

### 3. Free/Open-Source Security Tooling Landscape

#### SAST (Static Application Security Testing)

**Semgrep (open core, OSS engine + paid platform)**
- The dominant open-source SAST tool. Pattern-matching engine that understands code semantically. 30+ languages, 2,000+ community rules covering OWASP Top 10. Millisecond-per-file speed.
- **MCP Server:** Official MCP server (`uvx semgrep-mcp`) integrates directly into Claude Code, Cursor, VS Code/Copilot. Exposes `security_check`, `semgrep_scan`, custom rule scanning, and AST analysis. Runs locally via stdio or remotely via HTTP ([GitHub](https://github.com/semgrep/mcp)).
- **Cursor Hooks:** `afterFileEdit` hook triggers automatic Semgrep scans on agent-modified files. Agent receives findings and regenerates code until clean. `beforeSubmitPrompt` (future) will inject security context before generation. Cloud Distribution deploys guardrails org-wide ([Semgrep Blog](https://semgrep.dev/blog/2025/cursor-hooks-mcp-server/)).
- **Pre-commit:** `repos: [{repo: 'https://github.com/semgrep/semgrep', hooks: [{id: semgrep}]}]`
- 82% accuracy, 12% false positive rate, 90 seconds for 50K LOC ([sanj.dev benchmark](https://sanj.dev/post/ai-code-security-tools-comparison)).
- **License note:** In December 2024, Semgrep restricted its rule license for commercial/SaaS use. The scanning engine remains LGPL-2.1 open source.

**Opengrep (fully open-source Semgrep fork, LGPL-2.1)**
- Launched January 2025 by a consortium of 10+ security vendors (Endor Labs, Aikido, Arnica, Orca, etc.) in response to Semgrep's license change. Restores taint analysis, inter-procedural scanning, fingerprinting, and Windows support under LGPL-2.1.
- Drop-in replacement for Semgrep's scanning engine. Same rule syntax. Community maintains parity with upstream features.
- Source: [The New Stack](https://thenewstack.io/opengrep-launches-as-free-fork-after-semgrep-license-shift/), [Aikido](https://www.aikido.dev/blog/launching-opengrep-why-we-forked-semgrep)

**CodeQL (free for public repos, GitHub Advanced Security for private)**
- GitHub-native deep semantic analysis. 88% accuracy, 5% false positive rate (best precision). 15+ languages. Excellent dataflow tracking for complex vulnerability patterns.
- Slow: 8 minutes for 50K LOC. Best as CI gate, not real-time feedback.
- Free for all public repositories. $29/mo per committer via GitHub Advanced Security for private repos.
- Source: [sanj.dev benchmark](https://sanj.dev/post/ai-code-security-tools-comparison)

**Bearer CLI (fully open-source, MIT-adjacent)**
- Open-source SAST focused on data flow analysis. JavaScript, TypeScript, Ruby, Java, Go, Python. OWASP Top 10 and CWE Top 25 built-in rules.
- Unique value: prioritizes findings based on sensitive data flows (PII, credentials) — surfaces what's actually dangerous vs. theoretical.
- GitHub Actions and GitLab CI integration. GDPR/HIPAA compliance report generation.
- Source: [GitHub](https://github.com/Bearer/bearer), [bearer.com](https://www.bearer.com/bearer-cli)

**Bandit (fully open-source, Python-only)**
- Python security linter. Catches `eval()`, weak crypto, shell injection. Part of standard Python DevSecOps workflows. Fast, simple, well-maintained.
- Best as a pre-commit hook for Python projects alongside broader tools.

#### DAST (Dynamic Application Security Testing)

**OWASP ZAP (fully open-source, maintained by OWASP/Checkmarx)**
- The standard open-source DAST tool. Automated spider + active scan against running applications. REST and GraphQL API scanning via schema import.
- Official GitHub Actions: `zaproxy/action-full-scan`, `zaproxy/action-api-scan`, `zaproxy/action-baseline-scan`.
- Headless Docker mode for CI/CD: `docker run -t ghcr.io/zaproxy/zaproxy:stable zap-api-scan.py -t https://api.example.com/openapi.json -f openapi`.
- Source: [OWASP ZAP](https://www.zaproxy.org/), [GitHub Actions](https://github.com/zaproxy/action-full-scan)

**Nuclei (MIT license, fully open-source)**
- Template-based vulnerability scanner by ProjectDiscovery. 11,000+ YAML templates maintained by 210+ researchers. New CVE templates appear within hours of disclosure.
- Multi-protocol: HTTP, TCP, DNS, SSL, WHOIS. DAST via custom HTTP request/response matching.
- CI/CD integration for continuous monitoring of staging/production environments.
- Source: [GitHub](https://github.com/projectdiscovery/nuclei) (26,900+ stars)

#### Secret Detection

**Gitleaks (MIT license, fully open-source)**
- Lightweight, fast secret scanner. Comprehensive regex pattern database. Optimized for speed in pre-commit and CI workflows.
- Pre-commit hook integration and GitHub Action (`gitleaks/gitleaks-action`).
- Source: [GitHub](https://github.com/gitleaks/gitleaks)

**TruffleHog (open-source core, commercial enterprise)**
- 800+ secret type classifiers. Unique feature: **verification** — automatically checks if detected secrets are live/active, which is critical for triage.
- Pre-commit hook via git hookspath or pre-commit framework. GitHub Action available.
- Source: [GitHub](https://github.com/trufflesecurity/trufflehog)

#### Supply Chain / SCA (Software Composition Analysis)

**Socket.dev (free for open-source repos)**
- Behavioral analysis of dependencies — detects what packages *do* (network requests, shell access, env variable reading, filesystem operations), not just known CVEs. 70+ red flags. Detects typosquatting, maintainer changes, obfuscated code.
- GitHub App scans PRs automatically. CLI, VS Code extension, browser extension.
- npm registry now includes Socket analysis links on package pages.
- Source: [socket.dev](https://socket.dev/)

**Trivy (Apache 2.0, fully open-source)**
- Scans container images, filesystems, IaC configs, and dependencies for vulnerabilities. Lightweight, fast, multi-ecosystem.
- Source: [GitHub](https://github.com/aquasecurity/trivy)

#### Agent Security Skill/Context

**claude-code-owasp (open-source Claude Code skill)**
- Claude Code skill at `.claude/skills/owasp-security/SKILL.md`. Covers OWASP Top 10:2025, ASVS 5.0, Agentic AI ASI01-ASI10, and 20+ language-specific security quirks.
- Auto-activates during security-relevant tasks. Provides secure/unsafe code pattern pairs.
- Install: `curl -sL https://raw.githubusercontent.com/agam/claude-code-owasp/main/.claude/skills/owasp-security/SKILL.md -o .claude/skills/owasp-security/SKILL.md --create-dirs`
- Source: [GitHub](https://github.com/agamm/claude-code-owasp)

### 4. Integration Patterns for Agentic Workflows

The key insight from the research is that security in agentic engineering must operate at **three enforcement points**: before generation, during generation, and after generation.

#### Layer 1: Pre-Generation Context (Preventive)

Inject security knowledge *before* the agent writes code:

- **CLAUDE.md / .cursorrules security instructions:** The OpenSSF recommends specific, actionable security instructions in agent configuration files — not "act as a security expert" (which research shows *increases* vulnerabilities) but concrete rules: "Never hardcode secrets. Use parameterized queries. Validate all inputs with Zod." ([OpenSSF Guide](https://best.openssf.org/Security-Focused-Guide-for-AI-Code-Assistant-Instructions))
- **Claude Code OWASP skill:** Install the `claude-code-owasp` skill for automatic security context during relevant tasks.
- **RCI (Recursive Criticism and Improvement):** After generation, prompt the agent to review its own code for security issues, then improve. Research shows this reduces vulnerabilities by an order of magnitude vs. single-pass generation ([OpenSSF](https://best.openssf.org/Security-Focused-Guide-for-AI-Code-Assistant-Instructions)).

#### Layer 2: In-Flow Scanning (Detective, Real-Time)

Scan code as the agent produces it:

- **Semgrep MCP Server:** The highest-leverage integration for agentic workflows. The agent can call `security_check` on its own output before presenting it. Configuration for Claude Code / Cursor:
  ```json
  {
    "mcpServers": {
      "semgrep": {
        "command": "uvx",
        "args": ["semgrep-mcp"]
      }
    }
  }
  ```
- **Cursor Hooks + Semgrep:** `afterFileEdit` triggers deterministic Semgrep scan. Agent receives findings and iterates until clean. This is the strongest pattern — security runs via system infrastructure, not prompts, removing agent discretion ([Semgrep Blog](https://semgrep.dev/blog/2025/cursor-hooks-mcp-server/)).
- **Pre-commit hooks:** Semgrep + Gitleaks/TruffleHog as pre-commit hooks. In a 300-developer study, pre-commit security validation caught 40% of AI-generated security issues before CI/CD, reducing pipeline failures ([AppSec Santa](https://appsecsanta.com/api-ai-security/ai-code-security)).

#### Layer 3: CI/CD Pipeline Gates (Enforcement)

Hard gates that block vulnerable code from merging:

```yaml
# GitHub Actions example: multi-layer security pipeline
name: Security Gates
on: [pull_request]
jobs:
  sast:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Semgrep SAST
        uses: semgrep/semgrep-action@v1
        with:
          config: >-
            p/owasp-top-ten
            p/typescript
            p/javascript
        env:
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}
      - name: Bearer data flow scan
        run: |
          curl -sfL https://raw.githubusercontent.com/Bearer/bearer/main/contrib/install.sh | sh
          bearer scan . --format=sarif --output=bearer.sarif
      - name: Upload SARIF
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: bearer.sarif

  secrets:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}

  sca:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Trivy dependency scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'

  dast:
    runs-on: ubuntu-latest
    needs: [sast, secrets, sca]  # Only DAST if static checks pass
    steps:
      - name: ZAP API Scan
        uses: zaproxy/action-api-scan@v0.9.0
        with:
          target: ${{ vars.STAGING_API_URL }}/openapi.json
          format: openapi
```

#### Recommended Stack (Free/Open-Source)

For a TypeScript/Node.js project using AI coding agents:

| Layer | Tool | Cost | Integration Point |
|-------|------|------|-------------------|
| Pre-generation | claude-code-owasp skill | Free | `.claude/skills/` |
| Pre-generation | OpenSSF security instructions in CLAUDE.md | Free | Agent config |
| Real-time | Semgrep MCP Server | Free (OSS engine) | MCP config |
| Pre-commit | Semgrep + Gitleaks | Free | `.pre-commit-config.yaml` |
| CI SAST | Semgrep or Opengrep | Free (OSS) | GitHub Actions |
| CI SAST (data flow) | Bearer CLI | Free | GitHub Actions |
| CI Secrets | Gitleaks or TruffleHog | Free | GitHub Actions |
| CI SCA | Trivy | Free | GitHub Actions |
| CI DAST | OWASP ZAP | Free | GitHub Actions |
| PR Supply Chain | Socket.dev GitHub App | Free (OSS repos) | GitHub App |
| Deep Analysis | CodeQL | Free (public repos) | GitHub Advanced Security |

### 5. The OpenSSF Security-Focused Guide for AI Code Assistants

The OpenSSF (Open Source Security Foundation) published a comprehensive guide specifically for securing AI code assistant outputs. Key recommendations ([OpenSSF](https://best.openssf.org/Security-Focused-Guide-for-AI-Code-Assistant-Instructions)):

- **Treat all AI-generated code as untrusted** until it passes automated scanning + peer review + sandbox testing.
- **RCI technique** (Recursive Criticism and Improvement): Ask the AI to review its own code, find problems, then improve. Repeat. Reduces security weaknesses by ~10x.
- **Do NOT use the "persona pattern"** ("act as a security expert") — research shows this produces *more* vulnerabilities than other techniques.
- **Pin dependency versions** to prevent typosquatting and hallucinated package attacks (19.7% of AI-suggested packages don't exist).
- **Generate SBOMs** using SPDX or CycloneDX formats.
- **Container security:** Use minimal base images, never run as root, pin versions with SHA256 hashes (not `latest`), verify images with cosign.
- **Language-specific guidance:** Rust — avoid `unsafe`; Python — never `exec`/`eval` on user input, `subprocess` with `shell=False`; JS/TS — parameterized queries, output encoding for XSS; C/C++ — bounds-checked functions, compiler defenses.

### 6. Semgrep MCP + Cursor Hooks: The Highest-Leverage Pattern

The emerging best practice for agentic security is Semgrep's dual integration:

1. **MCP Server** provides tools the agent can call proactively (`security_check`, `semgrep_scan`), enabling the agent to self-audit.
2. **Cursor Hooks** provide deterministic enforcement — security scans run via system infrastructure on `afterFileEdit` and `stop` events, regardless of whether the agent "decides" to check. The agent cannot skip or bypass this check.

The principle: **security via APIs with deterministic invocation, not security via prompts**. Prompts are suggestions; hooks are guarantees. Organizations should deploy hooks via Cloud Distribution for uniform guardrails across all developers and agents ([Semgrep](https://semgrep.dev/blog/2025/cursor-hooks-mcp-server/)).

Future state: `beforeSubmitPrompt` hooks will inject organization-specific threat models and security context *before* agents generate code, making outputs safer from the start.

### 7. Benchmark: SAST Tool Comparison (2025)

Based on the [sanj.dev AI Code Security Benchmark](https://sanj.dev/post/ai-code-security-tools-comparison):

| Tool | Detection Score | Accuracy | False Positive Rate | Speed (50K LOC) | Cost |
|------|----------------|----------|--------------------|--------------------|------|
| Snyk Code | 92/100 | 85% | 8% | 45s (cloud) | $59/dev/mo |
| Semgrep | 87/100 | 82% | 12% | 90s (local) | $40/dev/mo (free OSS engine) |
| CodeQL | 84/100 | 88% | 5% | 8 min | $29/mo (GHAS) |

Key takeaway: Semgrep is the best balance of speed, cost (free engine), and breadth for agentic workflows. CodeQL has best precision but is too slow for real-time feedback. Snyk has best detection but is most expensive.

## Open Questions

1. **Claude Code hooks equivalent?** Cursor has `afterFileEdit` hooks for deterministic enforcement. Does Claude Code have or plan an equivalent hook system for automatic scanning after edits? Currently, the best Claude Code integration is via MCP server, which relies on agent discretion to call.

2. **Opengrep maturity:** Opengrep launched January 2025. Is the fork stable enough for production use, or does it still trail Semgrep's engine in features/reliability? Need to monitor the consortium's progress.

3. **LLM-powered SAST beyond pattern matching:** Tools like Corgea and ZeroPath use LLMs as part of the detection engine itself (not just post-processing). Early results suggest they can catch logic-level vulnerabilities that pattern-matching SAST misses. But are they mature enough, and can they be self-hosted/open-source?

4. **Agent-to-agent security scanning:** In multi-agent workflows (Claude Code Teams, CrewAI), should a dedicated security agent review all code produced by other agents? This "security reviewer agent" pattern is emerging but unvalidated.

5. **Pre-commit vs. MCP tradeoff:** Pre-commit hooks run on every commit but outside the agent's feedback loop. MCP runs in the agent's loop but is optional. Is there a way to make MCP scanning mandatory in Claude Code?

6. **DAST for local development:** OWASP ZAP and Nuclei require a running application. In agentic workflows where code is being generated rapidly, when is the right time to trigger DAST scans? Only on staging deploys, or can we run lightweight DAST locally?

## Extracted Principles

Principles distilled from this research have been added to `principles/security.md` under a new "Agentic Code Security" section:

1. **Three-Layer Security for Agentic Code** — Pre-generation context, in-flow scanning, CI/CD enforcement.
2. **Deterministic Enforcement Over Prompt-Based Security** — Hooks and CI gates over agent instructions.
3. **Treat AI-Generated Code as Untrusted** — Same rigor as third-party code until scanned and reviewed.
4. **Semgrep MCP as the Minimum Agentic Security Integration** — Lowest friction, highest coverage free tool.
5. **Secret Detection is Non-Negotiable for AI Workflows** — Agents hallucinate and hardcode secrets at high rates.
